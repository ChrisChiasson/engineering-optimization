graph         { flow: south; }
node.start    { shape: rounded; fill: #ffbfc9; }
node.question { shape: diamond; fill: #ffff8a; }
node.action   { shape: rounded; fill: #8bef91; }

[ Given: f, a, c,\nlimitLeft,\nlimitRight,\nreverse,\nshrinkFactor,\ngrowthFactor,\naccuracyGoal,\nprecisionGoal,\nmaxWideningIterations,\nmaxNarrowingIterations ] { class: start }
  --> [ {fa,fc} =\n{f(a),f(c)} ] {class: action; }
    --> [ if fc > fa ] { class: question; }
      -- then --> [ {fa,a,fc,c} =\n{fc,c,fa,a} ] { class: action; }
        --> [ if reverse ] { class: question; }
	  -- then --> [ {fc,c,fa,a} =\n{fa,a,fc,c} ] { class: action; }
	    --> [ b = c + shrinkFactor*(a-c) ] { class: action; }
	      --> [ fb = f(b) ] { class: action; }
	        --> [ iteration = 1 ] { class: action; }
		  --> [ if fc > fb ] { class: question; }
		    -- then --> [ frameBound = True ] { class: action; }
		      --> [ cdomain ] { class: question; label: if Or(c == limitLeft,\nc == limitRight); }
		        -- then --> [ domainBound = True ] { class: action; }
			  --> [ if iteration ==\nmaxWideningIterations ] { class: question; }
			    -- then --> [ iterationBound = True ] { class: action; }
			      --> [ frameMinimumStopTest ] { class: question; label: if Or(frameBound,\ndomainBound,\niterationBound); }
			        -- then --> [ if And(Not(frameBound,\nNot(reverse)) ] { class: question; }
				  -- then --> [ Sow (a.k.a. store)\nthe results of running\nthis algorithm with\nreverse = False ] { class: action; }
				    --> [ if frameBound ] { class: question; }
				      -- then --> [ {fa,a,fb,b,fc,c} =\npair sorted\n{fa,a,fb,b,fc,c}\nin order of\nincreasing\nabscissa ] { class: action; }
				        --> [ {fu,u} =\n{fc,c} ] { class: action; }
					  --> [ {fv,v,fw,w,fx,x} =\npair sorted\n{fa,a,fb,b,fc,c}\nin order of\ndecreasing\nordinate ] { class: action; }
					    --> [ maxDisplacement =\nc-a ] { class: action; }
					      --> [ xtol = 10^-accuracyGoal +\nAbs(x)*10^-precisionGoal ] { class: action; }
					        --> [ if And(Abs(a-x) < xtol,\nAbs(c-x) < xtol) ] { class: question; }
						  -- then --> [done with frame narrow]

[ if fc > fa ]
   -- else --> [ if reverse ]

[ if reverse ]
  -- else --> [ b = c + shrinkFactor*(a-c) ]

[ if fc > fb ]
  -- else --> [ cdomain ]
    -- else --> [ if iteration ==\nmaxWideningIterations ]
      -- else --> [ frameMinimumStopTest ]
        -- else --> [ newAbscissa = c + growthFactor*(c-b) ] { class: action; }
	  --> [ if newAbscissa <=\nlowerLimit ] { class: question; }
	    -- then --> [ newAbscissa = lowerLimit ] { class: action; }
	      --> [ if newAbscissa >=\nupperLimit ] { class: question; }
	        -- then --> [ newAbscissa = upperLimit ] { class: action; }
		  --> [ iteration++ ] { class: action; }
		    --> [ newOrdinate =\nf(newAbscissa) ] { class: action; }
		      --> [ {fa,a,fb,b,fc,c} =\n{fb,b,fc,c,newOrdinate,newAbscissa} ] { class: action; }
		        --> [ if fc > fb ]


[ if newAbscissa <=\nlowerLimit ]
  -- else --> [ if newAbscissa >=\nupperLimit ]
    -- else --> [ iteration++ ]

[ if And(Not(frameBound,\nNot(reverse)) ]
  -- else --> [ if frameBound ]

[ if And(Abs(a-x) < xtol,\nAbs(c-x) < xtol) ]
  -- else --> [ if x > (a + c)/2 ] { class: question; }
    -- then --> [ e = a - x ] { class: action; }
      --> [ define candidateAbsicssa(1)\nvia inverse polynomial\ninterpolation ] { class: action; }
        --> [ candidateAbscissa(2) = x + e*shrinkFactor ] { class: action; }
	  --> [ perturbed = candidateAbscissa ] { class: action; }
	    --> [ perturbationFactor =\nSign(e)/2 ] { class: action; }
	      --> [ sameTestAbscissas =\n{x,u,c,a,w,c} ] { class: action; }
	        --> [ i = 0 ] { class: action; }
		  --> [ i++ ] { class: action; }
		    --> [ if i >\nLength(perturbed) ] { class: question; }
		      -- then --> [ Select from perturbed\na list containing\nthe first and\nonly the first\nabscissa between\na and c that represents\na displacement less than\nmaxAcceptableDisplacement from x.\nCall it newAbscissa. ] { class: action; }
		        --> [ if newAbscissa == {}\n(if no perturbed points\nmet the criteria) ]  { class: question; }
			  -- then --> [ newAbscissa =\nperturbed =\ncandidateAbscissa =\n{candidateAbsicssa(2)} ] { class: action; }
			    --> [ newAbscissa = newAbscissa(1) ] { class: action; }
		    
[ if x > (a + c)/2 ]
  -- else --> [ e = c - x ] { class: action; }
    --> [ define candidateAbsicssa(1)\nvia inverse polynomial\ninterpolation ]

[ if i >\nLength(perturbed) ] { class: question; }
  -- else --> [ ptol = 10^-accuracyGoal +\nAbs(perturbed(i))*10^-precisionGoal ] { class: action; }
    --> [ j = 0 ] { class: action; }
      --> [ j++ ] { class: action; }
        --> [ if j >\nLength(sameTestAbscissas) ] { class: question; }
	  -- then --> [ i++ ]

[ if j >\nLength(sameTestAbscissas) ]
  -- else --> [ if Abs(sameTestAbscissas(j) -\nperturbed(i)) < ptol ] { class: question; }
    -- then --> [ perturbed(i) =\n perturbed(i) +\nperturbFactor*tol ] { class: action; }
      --> [ ptol = 10^-accuracyGoal +\nAbs(perturbed(i))*10^-precisionGoal ]

[ if Abs(sameTestAbscissas(j) -\nperturbed(i)) < ptol ]
  -- else --> [ j++ ]

[ if newAbscissa == {}\n(if no perturbed points\nmet the criteria) ]
  -- else --> [ newAbscissa = newAbscissa(1) ]